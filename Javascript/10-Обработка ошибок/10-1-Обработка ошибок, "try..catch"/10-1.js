// Сравните два фрагмента кода.
// 
// Первый использует finally для выполнения кода после try..catch:
// 
// try {
//   начать работу
//   работать
// } catch (e) {
//   обработать ошибку
// } finally {
//   очистить рабочее пространство
// }
//
// Второй фрагмент просто ставит очистку после try..catch:
// 
// try {
//   начать работу
//   работать
// } catch (e) {
//   обработать ошибку
// }
// 
// очистить рабочее пространство
//
// Нам определённо нужна очистка после работы, неважно возникли ошибки или нет.
// Есть ли здесь преимущество в использовании finally или оба фрагмента кода одинаковы? 
// Если такое преимущество есть, то дайте пример, когда оно проявляется.
//-----------------------------------------------------//

// Преимущество будет намного нагляднее, если мы будем использовать конструкцию
// try .. catch .. finally внутри функции. Например, если мы что-то возвращаем или делаем throw
// внутри try .. catch и при этом хотим, чтобы вне зависимости от результата выполнения этой конструкции
// после также выполнялся какой-то код, то добиться этого можно лишь с помощью finally.
// finally выполнится в любом случае, после того, как try .. catch выполнится.